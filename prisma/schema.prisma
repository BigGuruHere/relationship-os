/// Relationship OS - Prisma schema
/// Vectors:
/// - We use pgvector columns for embeddings.
/// - InteractionEmbedding.vec and Tag.embedding_vec are type vector(1536).
/// - Prisma maps vectors using Unsupported("vector") and we write values via raw SQL with ::vector casts.
/// Tenant scoping:
/// - Every model that is user data includes userId and all queries must filter by userId on read and write.
/// Encryption:
/// - PII fields are AES-256-GCM encrypted server side only, with deterministic HMAC indexes for equality search.

// ---------------------------------------------------------------------------
// Datasource and generator
// ---------------------------------------------------------------------------
generator client {
  provider = "prisma-client-js" // Generate Prisma Client for Node and TS
}

datasource db {
  provider          = "postgresql" // Using Postgres
  url               = env("DATABASE_URL") // Connection string from your .env
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // optional - only used by migrate dev
}

// IT: role for feature gating
enum UserRole {
  owner
  member
  guest
}

// ---------------------------------------------------------------------------
// AUTH MODELS
// ---------------------------------------------------------------------------
// MODEL: User
// - Primary account for a single tenant
// - Email is stored encrypted at rest with a deterministic HMAC index for equality
model User {
  id           String   @id @default(uuid()) // pk stored as text uuid
  passwordHash String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // IT: encrypted and indexed email - replaces legacy plaintext email
  email_Enc String? // ciphertext at rest
  email_Idx Bytes?  @unique // deterministic HMAC index for equality search

  // Owned data - tenant boundaries
  sessions      Session[]
  contacts      Contact[]
  interactions  Interaction[]
  tags          Tag[]
  oauthAccounts OAuthAccount[] // external accounts linked to this user

  // IT: back-relation for one-shot reminders
  reminders Reminder[]

  role       UserRole @default(member)
  publicSlug String?  @unique

  // relations
  magicTokens  MagicToken[]
  inviteTokens InviteToken[] @relation("OwnerInvites")

  profiles Profile[]

  @@index([createdAt])
}

// IT: New table to track claimable leads
model Lead {
  id              String     @id @default(uuid())
  ownerId         String
  contactId       String
  // IT: store deterministic indexes to match later without decrypting
  emailIdx        String?    @db.VarChar(128)
  phoneIdx        String?    @db.VarChar(128)
  linkedinIdx     String?    @db.VarChar(128)

  linkedinEnc     String?

  // IT: claim status
  status          LeadStatus @default(PENDING)
  claimedByUserId String?
  inviteToken     String?
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([ownerId])
  @@index([emailIdx])
  @@index([phoneIdx])
  @@index([linkedinIdx])
  @@unique([ownerId, linkedinIdx])
}

enum LeadStatus {
  PENDING
  CLAIMED
}

// IT: single use sign in tokens for magic link login
model MagicToken {
  id        String    @id @default(uuid())
  userId    String
  // IT: store only an HMAC of the token - never the raw token
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// IT: short lived token that binds a public profile page to the owner
model InviteToken {
  id        String    @id @default(uuid())
  ownerId   String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  owner User @relation("OwnerInvites", fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([ownerId])
}

// PURPOSE: link external OAuth providers like Google to a local User
model OAuthAccount {
  id String @id @default(uuid()) // pk

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  provider          String // e.g. "google"
  providerAccountId String // stable provider user id - for Google this is the "sub" claim
  // IT: removed plaintext email - provider email is handled via User.email_Enc and User.email_Idx
  accessToken       String?
  refreshToken      String?
  expiresAt         DateTime?

  createdAt DateTime @default(now())

  @@unique([provider, providerAccountId]) // prevent duplicate links
  @@index([userId])
}

// MODEL: Session
// - Stores session token hash and expiry
// - tokenHash is a server side HMAC of a random token sent to the browser
model Session {
  id     String @id @default(uuid()) // pk
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash String   @unique // HMAC of random token
  createdAt DateTime @default(now())
  expiresAt DateTime // absolute expiry

  @@index([userId])
}

// ---------------------------------------------------------------------------
// ENUMS
// ---------------------------------------------------------------------------
enum CreatedBy {
  ai
  user
}

enum AssignedBy {
  ai
  user
}

// IT: Tag - pgvector tracked by Prisma without a native type
model Tag {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name      String
  slug      String
  createdBy CreatedBy
  createdAt DateTime  @default(now())

  // IT: pgvector column - Prisma tracks but does not parse
  embeddingVec Unsupported("vector")? @map("embedding_vec")

  mergedIntoId String?
  mergedInto   Tag?    @relation(name: "TagMerge", fields: [mergedIntoId], references: [id])
  mergedFrom   Tag[]   @relation(name: "TagMerge")

  aliases  TagAlias[]
  contacts ContactTag[]

  @@unique([userId, name])
  @@unique([userId, slug])
  @@index([userId, createdBy, createdAt])
  @@map("Tag")
}

// ---------------------------------------------------------------------------
// MODEL: TagAlias
// ---------------------------------------------------------------------------
model TagAlias {
  id String @id @default(uuid())

  tagId String
  tag   Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  alias String
  slug  String

  @@unique([tagId, slug])
}

// ---------------------------------------------------------------------------
// MODEL: Contact
// Encrypted PII plus deterministic HMAC index columns - tenant scoped
// ---------------------------------------------------------------------------
model Contact {
  id String @id @default(uuid()) // pk

  // Tenant ownership
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Encrypted at rest fields
  fullNameEnc String
  emailEnc    String?
  phoneEnc    String?
  companyEnc  String?

  // Deterministic indexable tokens
  fullNameIdx String
  emailIdx    String? @unique
  phoneIdx    String?
  companyIdx  String?

  positionEnc String?
  positionIdx String?

  linkedinEnc String?
  linkedinIdx String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reconnectEveryDays Int?
  lastContactedAt    DateTime?

  // Relations
  interactions Interaction[]
  tags         ContactTag[]
  linkedUserId String?

  reminders Reminder[]

  // Indexes for search and tenancy
  @@index([userId])
  @@index([fullNameIdx])
  @@index([phoneIdx])
  @@index([companyIdx])
}

// ---------------------------------------------------------------------------
// MODEL: Interaction
// ---------------------------------------------------------------------------
model Interaction {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  occurredAt DateTime @default(now())
  channel    String
  rawTextEnc String
  summaryEnc String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  InteractionEmbedding InteractionEmbedding?

  @@index([userId])
  @@index([contactId])
  @@index([occurredAt])
}

// IT: InteractionEmbedding - pgvector tracked the same way
model InteractionEmbedding {
  interactionId String      @id
  interaction   Interaction @relation(fields: [interactionId], references: [id], onDelete: Cascade)

  vec Unsupported("vector")? @map("vec")

  @@map("InteractionEmbedding")
}

// ---------------------------------------------------------------------------
// MODEL: ContactTag
// ---------------------------------------------------------------------------
model ContactTag {
  contactId String
  tagId     String

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  assignedBy AssignedBy
  assignedAt DateTime   @default(now())

  @@id([contactId, tagId])
  @@index([tagId])
}

// IT: one-shot reminders with optional auto-roll if you want later
model Reminder {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  dueAt DateTime
  note  String?
  completedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId, dueAt])
  @@index([userId, contactId, dueAt])
}

// IT: types of profiles - extend later if needed
enum ProfileKind {
  business
  personal
  dating
  custom
}

// IT: public shareable profile owned by a user
model Profile {
  id        String      @id @default(uuid())
  userId    String
  kind      ProfileKind @default(business)
  label     String      @default("My profile")
  slug      String      @unique
  isDefault Boolean     @default(false)

  // Public fields only
  displayName String?
  headline    String?
  bio         String?
  avatarUrl   String?
  company     String?
  title       String?
  websiteUrl  String?
  emailPublic String?
  phonePublic String?
  socials     Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  qrReady       Boolean   @default(false)
  qrSvg         String?
  qrGeneratedAt DateTime?

  publicMeta Json?

  @@index([userId, isDefault])
}
