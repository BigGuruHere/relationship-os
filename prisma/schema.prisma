// prisma/schema.prisma
// PURPOSE: Personal CRM schema with multi tenant auth and normalized tagging
// NOTES:
// - Postgres is assumed
// - All IT code is commented
// - Tenant scoping is enforced by required userId on Contact, Interaction, and Tag
// - Embeddings are stored as double precision[] - no pgvector required

// ---------------------------------------------------------------------------
// Datasource and generator
// ---------------------------------------------------------------------------
generator client {
  provider = "prisma-client-js" // Generate Prisma Client for Node and TS
}

datasource db {
  provider          = "postgresql"           // Using Postgres
  url               = env("DATABASE_URL")    // Connection string from your .env
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // optional - only used by migrate dev
}

// ---------------------------------------------------------------------------
// AUTH MODELS
// ---------------------------------------------------------------------------
// MODEL: User
// - Primary account for a single tenant
// - Email is unique per deployment
model User {
  id           String    @id @default(uuid())         // pk stored as text uuid
  email        String    @unique                      // login identifier
  passwordHash String                                 // Argon2id hash string

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Owned data - tenant boundaries
  sessions      Session[]
  contacts      Contact[]
  interactions  Interaction[]
  tags          Tag[]
  oauthAccounts OAuthAccount[] // external accounts linked to this user

}

// PURPOSE: link external OAuth providers like Google to a local User
model OAuthAccount {
  id                String   @id @default(uuid()) // pk

  userId            String
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  provider          String   // e.g. "google"
  providerAccountId String   // stable provider user id - for Google this is the "sub" claim
  email             String?  // convenience copy of provider email
  accessToken       String?  // optional if you request additional API scopes
  refreshToken      String?  // optional if you request offline access
  expiresAt         DateTime?

  createdAt         DateTime @default(now())

  @@unique([provider, providerAccountId]) // prevent duplicate links
  @@index([userId])
}


// MODEL: Session
// - Stores session token hash and expiry
// - tokenHash is a server side HMAC of a random token sent to the browser
model Session {
  id         String   @id @default(uuid())                   // pk
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash  String   @unique                                // HMAC of random token
  createdAt  DateTime @default(now())
  expiresAt  DateTime                                        // absolute expiry

  @@index([userId])
}

// ---------------------------------------------------------------------------
// ENUMS
// ---------------------------------------------------------------------------
// Prevents strings like "ai " etc
enum CreatedBy {
  ai
  user
}

enum AssignedBy {
  ai
  user
}

// MODEL: Tag
// A single tag concept - tenant scoped
// name and slug are unique per user to avoid cross tenant collisions
model Tag {
  id        String   @id @default(uuid()) // pk
  userId    String                              // tenant owner - required
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  name      String                              // human label, e.g. "vc"
  slug      String                              // normalized, e.g. "climate-tech"

  createdBy CreatedBy
  createdAt DateTime @default(now())

  // Store an embedding for the tag vocabulary to enable cosine similarity
  // Prisma maps Float[] to Postgres double precision[]
  // Lists cannot be optional in Prisma, so default to an empty array to mean "not computed yet"
  embedding Float[] @default([])

  // Merge governance - self relation pattern
  mergedIntoId String?
  mergedInto   Tag?   @relation(name: "TagMerge", fields: [mergedIntoId], references: [id])
  mergedFrom   Tag[]  @relation(name: "TagMerge")

  // Aliases and usage relations
  aliases      TagAlias[]
  contacts     ContactTag[]
  interactions InteractionTag[]

  // Tenant aware uniqueness and indexes
  @@unique([userId, name])
  @@unique([userId, slug])
  @@index([userId, createdBy, createdAt])
  @@map("Tag")
}



// ---------------------------------------------------------------------------
// MODEL: TagAlias
// Alternative names mapped to a Tag - tenant scoped implicitly via Tag.userId
// ---------------------------------------------------------------------------
model TagAlias {
  id    String @id @default(uuid())

  tagId String
  tag   Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  alias String                     // human facing alias
  slug  String                     // normalized alias for lookups

  @@unique([tagId, slug])          // alias slug unique per tag
}

// ---------------------------------------------------------------------------
// MODEL: Contact
// Encrypted PII plus deterministic HMAC index columns - tenant scoped
// ---------------------------------------------------------------------------
model Contact {
  id     String @id @default(uuid()) // pk

  // Tenant ownership - required
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Encrypted at rest fields
  fullNameEnc String
  emailEnc    String?
  phoneEnc    String?

  // Deterministic indexable tokens - used in WHERE clauses
  fullNameIdx String
  emailIdx    String? @unique // unique when present - Postgres allows multiple NULLs
  phoneIdx    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  interactions Interaction[]
  tags         ContactTag[]

  // Indexes for search and tenancy
  @@index([userId])
  @@index([fullNameIdx])
  @@index([phoneIdx])
}

// ---------------------------------------------------------------------------
// MODEL: Interaction
// Minimal history entry linked to a Contact - encrypted raw text - tenant scoped
// ---------------------------------------------------------------------------
model Interaction {
  id        String  @id @default(uuid())
  userId    String                               // tenant owner - required
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  occurredAt DateTime @default(now())
  channel    String
  rawTextEnc String
  summaryEnc String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tags                 InteractionTag[]
  InteractionEmbedding InteractionEmbedding?

  @@index([userId])
  @@index([contactId])
  @@index([occurredAt])
}

// ---------------------------------------------------------------------------
// MODEL: InteractionEmbedding
// Store interaction embeddings as Postgres double precision[] - no pgvector
// ---------------------------------------------------------------------------
model InteractionEmbedding {
  interactionId String      @id                                // pk mirrors parent id
  interaction   Interaction @relation(fields: [interactionId], references: [id], onDelete: Cascade)

  // Prisma maps Float[] to Postgres double precision[]
  embedding     Float[]
}

// ---------------------------------------------------------------------------
// MODEL: ContactTag
// Join table linking Contact to Tag with assignment metadata - tenant handled by FKs
// Composite primary key prevents duplicate links
// ---------------------------------------------------------------------------
model ContactTag {
  contactId  String
  tagId      String

  contact    Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag        Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  assignedBy AssignedBy
  assignedAt DateTime   @default(now()) // When the link was created

  @@id([contactId, tagId]) // Composite PK - unique per pair
  @@index([tagId])
}

// ---------------------------------------------------------------------------
// MODEL: InteractionTag
// Join table linking Interaction to Tag with assignment metadata - tenant handled by FKs
// Composite primary key prevents duplicate links
// ---------------------------------------------------------------------------
model InteractionTag {
  interactionId String
  tagId         String

  interaction   Interaction @relation(fields: [interactionId], references: [id], onDelete: Cascade)
  tag           Tag         @relation(fields: [tagId], references: [id], onDelete: Cascade)

  assignedBy    AssignedBy
  assignedAt    DateTime   @default(now()) // When the link was created

  @@id([interactionId, tagId]) // Composite PK - unique per pair
  @@index([tagId])
}
