/// Relationship OS - Prisma schema
/// Vectors:
/// - We use pgvector columns for embeddings.
/// - InteractionEmbedding.vec and Tag.embedding_vec are type vector(1536).
/// - Prisma maps vectors using Unsupported("vector") and we write values via raw SQL with ::vector casts.
/// Tenant scoping:
/// - Every model that is user data includes userId and all queries must filter by userId on read and write.
/// Encryption:
/// - PII fields are AES-256-GCM encrypted server side only, with deterministic HMAC indexes for equality search.

// ---------------------------------------------------------------------------
// Datasource and generator
// ---------------------------------------------------------------------------
generator client {
  provider = "prisma-client-js" // Generate Prisma Client for Node and TS
}

datasource db {
  provider          = "postgresql" // Using Postgres
  url               = env("DATABASE_URL") // Connection string from your .env
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // optional - only used by migrate dev
}

// IT: role for feature gating
enum UserRole {
  owner
  member
  guest
}

// ---------------------------------------------------------------------------
// AUTH MODELS
// ---------------------------------------------------------------------------
// MODEL: User
// - Primary account for a single tenant
// - Email is unique per deployment
model User {
  id           String  @id @default(uuid()) // pk stored as text uuid
  email        String  @unique // login identifier
  passwordHash String? // was String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Owned data - tenant boundaries
  sessions      Session[]
  contacts      Contact[]
  interactions  Interaction[]
  tags          Tag[]
  oauthAccounts OAuthAccount[] // external accounts linked to this user

  // IT: back-relation for one-shot reminders
  reminders Reminder[]

  role       UserRole @default(member)
  publicSlug String?  @unique

  // relations
  // magic tokens issued for this user
  magicTokens  MagicToken[]
  // invites if this user is the owner being connected to
  inviteTokens InviteToken[] @relation("OwnerInvites")

  profiles Profile[]
}

// IT: New table to track claimable leads
model Lead {
  id              String     @id @default(uuid())
  ownerId         String
  contactId       String
  // IT: store deterministic indexes to match later without decrypting
  emailIdx        String?    @db.VarChar(128)
  phoneIdx        String?    @db.VarChar(128)
  // IT: claim status
  status          LeadStatus @default(PENDING)
  claimedByUserId String?
  inviteToken     String? // optional - last generated token
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([ownerId])
  @@index([emailIdx])
  @@index([phoneIdx])
}

enum LeadStatus {
  PENDING
  CLAIMED
}

// IT: single use sign in tokens for magic link login
model MagicToken {
  id        String    @id @default(uuid())
  userId    String
  // IT: store only an HMAC of the token - never the raw token
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// IT: short lived token that binds a public profile page to the owner
model InviteToken {
  id        String    @id @default(uuid())
  ownerId   String
  tokenHash String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  owner User @relation("OwnerInvites", fields: [ownerId], references: [id], onDelete: Cascade)

  @@index([ownerId])
}

// PURPOSE: link external OAuth providers like Google to a local User
model OAuthAccount {
  id String @id @default(uuid()) // pk

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  provider          String // e.g. "google"
  providerAccountId String // stable provider user id - for Google this is the "sub" claim
  email             String? // convenience copy of provider email
  accessToken       String? // optional if you request additional API scopes
  refreshToken      String? // optional if you request offline access
  expiresAt         DateTime?

  createdAt DateTime @default(now())

  @@unique([provider, providerAccountId]) // prevent duplicate links
  @@index([userId])
}

// MODEL: Session
// - Stores session token hash and expiry
// - tokenHash is a server side HMAC of a random token sent to the browser
model Session {
  id     String @id @default(uuid()) // pk
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tokenHash String   @unique // HMAC of random token
  createdAt DateTime @default(now())
  expiresAt DateTime // absolute expiry

  @@index([userId])
}

// ---------------------------------------------------------------------------
// ENUMS
// ---------------------------------------------------------------------------
// Prevents strings like "ai " etc
enum CreatedBy {
  ai
  user
}

enum AssignedBy {
  ai
  user
}

// IT: Tag - pgvector tracked by Prisma without a native type
model Tag {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  name      String
  slug      String
  createdBy CreatedBy
  createdAt DateTime  @default(now())

  // IT: pgvector column - Prisma tracks but does not parse
  embeddingVec Unsupported("vector")? @map("embedding_vec")

  mergedIntoId String?
  mergedInto   Tag?    @relation(name: "TagMerge", fields: [mergedIntoId], references: [id])
  mergedFrom   Tag[]   @relation(name: "TagMerge")

  aliases  TagAlias[]
  contacts ContactTag[]

  @@unique([userId, name])
  @@unique([userId, slug])
  @@index([userId, createdBy, createdAt])
  @@map("Tag")
}

// ---------------------------------------------------------------------------
// MODEL: TagAlias
// Alternative names mapped to a Tag - tenant scoped implicitly via Tag.userId
// ---------------------------------------------------------------------------
model TagAlias {
  id String @id @default(uuid())

  tagId String
  tag   Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  alias String // human facing alias
  slug  String // normalized alias for lookups

  @@unique([tagId, slug]) // alias slug unique per tag
}

// ---------------------------------------------------------------------------
// MODEL: Contact
// Encrypted PII plus deterministic HMAC index columns - tenant scoped
// ---------------------------------------------------------------------------
model Contact {
  id String @id @default(uuid()) // pk

  // Tenant ownership - required
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Encrypted at rest fields
  fullNameEnc String
  emailEnc    String?
  phoneEnc    String?
  companyEnc  String? // IT: new

  // Deterministic indexable tokens - used in WHERE clauses
  fullNameIdx String
  emailIdx    String? @unique // unique when present - Postgres allows multiple NULLs
  phoneIdx    String?
  companyIdx  String? // IT: new

  positionEnc String? // AES-256-GCM ciphertext
  positionIdx String?

  linkedinEnc String?
  linkedinIdx String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // IT: new - how often to reconnect in days, null means no cadence
  reconnectEveryDays Int? // e.g. 60

  // IT: new - when we last interacted - maintained by server on interaction create
  lastContactedAt DateTime? // used to compute next reconnect

  // Relations
  interactions Interaction[]
  tags         ContactTag[]
  linkedUserId String? // when the lead is claimed, we set this

  // IT: back-relation for one-shot reminders
  reminders Reminder[]

  // Indexes for search and tenancy
  @@index([userId])
  @@index([fullNameIdx])
  @@index([phoneIdx])
  @@index([companyIdx]) // IT: new
}

// ---------------------------------------------------------------------------
// MODEL: Interaction
// Minimal history entry linked to a Contact - encrypted raw text - tenant scoped
// ---------------------------------------------------------------------------
model Interaction {
  id     String @id @default(uuid())
  userId String // tenant owner - required
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  occurredAt DateTime @default(now())
  channel    String
  rawTextEnc String
  summaryEnc String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  InteractionEmbedding InteractionEmbedding?

  @@index([userId])
  @@index([contactId])
  @@index([occurredAt])
}

// IT: InteractionEmbedding - pgvector tracked the same way
model InteractionEmbedding {
  interactionId String      @id
  interaction   Interaction @relation(fields: [interactionId], references: [id], onDelete: Cascade)

  vec Unsupported("vector")? @map("vec")

  @@map("InteractionEmbedding")
}

// ---------------------------------------------------------------------------
// MODEL: ContactTag
// Join table linking Contact to Tag with assignment metadata - tenant handled by FKs
// Composite primary key prevents duplicate links
// ---------------------------------------------------------------------------
model ContactTag {
  contactId String
  tagId     String

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  assignedBy AssignedBy
  assignedAt DateTime   @default(now()) // When the link was created

  @@id([contactId, tagId]) // Composite PK - unique per pair
  @@index([tagId])
}

// IT: one-shot reminders with optional auto-roll if you want later
model Reminder {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  // IT: due date for notification
  dueAt DateTime

  // IT: optional note like "send deck"
  note String?

  // IT: status - completed when user marks done
  completedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId, dueAt])
  @@index([userId, contactId, dueAt])
}

// IT: types of profiles - extend later if needed
enum ProfileKind {
  business
  personal
  dating
  custom
}

// IT: public shareable profile owned by a user
model Profile {
  id        String      @id @default(uuid())
  userId    String
  kind      ProfileKind @default(business) // default type - change per profile
  label     String      @default("My profile") // shown in Settings list
  slug      String      @unique // direct link like /p/{slug} (optional)
  isDefault Boolean     @default(false) // only one per user should be true

  // IT: public fields intended for sharing - plaintext is fine because these are public
  displayName String?
  headline    String?
  bio         String?
  avatarUrl   String?
  company     String?
  title       String?
  websiteUrl  String?
  emailPublic String?
  phonePublic String?
  socials     Json? // { twitter, linkedin, instagram, website2, etc }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  qrReady       Boolean   @default(false)
  qrSvg         String?
  qrGeneratedAt DateTime?

  // in model Profile
  publicMeta Json?

  @@index([userId, isDefault])
}
