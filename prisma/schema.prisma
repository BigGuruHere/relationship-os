// prisma/schema.prisma
// PURPOSE: Personal CRM schema with normalized tagging
// NOTES:
// - Postgres is assumed
// - All IT code is commented
// - Legacy Contact.tags String[] has been removed in favor of join tables
// - If you still have data in Contact.tags, backfill before applying a destructive migration

// ---------------------------------------------------------------------------
// Datasource and generator
// ---------------------------------------------------------------------------
datasource db {
  provider          = "postgresql" // Using Postgres
  url               = env("DATABASE_URL") // Connection string from your .env
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // different DB for shadows
}

generator client {
  provider = "prisma-client-js" // Generate Prisma Client for Node and TS
}

// Prevents strings like "AI " or "usr"
// Put enum values on separate lines
enum CreatedBy {
  ai
  user
}

enum AssignedBy {
  ai
  user
}

// ---------------------------------------------------------------------------
// MODEL: Tag
// A single tag concept. Name is human facing. Slug is machine normalized
// to ensure uniqueness and stable lookups.
// ---------------------------------------------------------------------------
// MODEL: Tag - corrected self relation for merges
model Tag {
  id        String    @id @default(uuid()) // pk
  name      String // human label, e.g. "vc"
  slug      String    @unique // normalized, e.g. "climate-tech"
  createdBy CreatedBy
  createdAt DateTime  @default(now())

  // Merge governance
  mergedIntoId String? // if this tag was merged into another
  mergedInto   Tag?    @relation(name: "TagMerge", fields: [mergedIntoId], references: [id])
  mergedFrom   Tag[]   @relation(name: "TagMerge") // inverse side required for self relation

  // Aliases and usage relations
  aliases      TagAlias[]
  contacts     ContactTag[]
  interactions InteractionTag[]

  @@unique([name])
  @@index([createdBy, createdAt])
}

// ---------------------------------------------------------------------------
// MODEL: TagAlias
// Alternative human names and normalized slugs that point to a Tag.
// Example: alias "venture capitalist" slug "venture-capitalist" for Tag "vc".
// ---------------------------------------------------------------------------
model TagAlias {
  id String @id @default(uuid()) // Primary key

  tagId String // FK to Tag
  tag   Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  alias String // Human facing alias
  slug  String @unique // Normalized alias for stable lookups

  @@unique([tagId, slug])
}

// ---------------------------------------------------------------------------
// MODEL: Contact
// Stores encrypted fields and deterministic HMAC index fields for equality search.
// Interaction history is kept in Interaction. Tags are linked via ContactTag.
// ---------------------------------------------------------------------------
model Contact {
  id String @id @default(uuid()) // Primary key

  // Encrypted-at-rest fields
  fullNameEnc String
  emailEnc    String?
  phoneEnc    String?

  // Deterministic, indexable tokens - used in WHERE clauses
  fullNameIdx String
  emailIdx    String? @unique // Unique when present - Postgres allows multiple NULLs
  phoneIdx    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  interactions Interaction[] // One-to-many - a contact has many interactions
  tags         ContactTag[] // Many-to-many via ContactTag

  // Indexes for search
  @@index([fullNameIdx])
  @@index([phoneIdx])
}

// ---------------------------------------------------------------------------
// MODEL: Interaction
// Minimal history entry linked to a Contact. Stores encrypted body in rawTextEnc.
// Tags are linked via InteractionTag.
// ---------------------------------------------------------------------------
model Interaction {
  id        String  @id @default(uuid())
  contactId String
  contact   Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)

  occurredAt DateTime @default(now())
  channel    String
  rawTextEnc String
  summaryEnc String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // remove the embedding field here - moved to its own table
  // embedding   Float[]? @db.Vector(1536)

  tags InteractionTag[]

  // no vector index here anymore
  InteractionEmbedding InteractionEmbedding[]
}

model InteractionEmbedding {
  interactionId String                @id
  interaction   Interaction           @relation(fields: [interactionId], references: [id], onDelete: Cascade)
  // Use Unsupported so Prisma does not try to map it. We will read and write via raw SQL.
  embedding     Unsupported("vector")

  // Remove any Prisma-level index declarations for this field
  // The ivfflat index is created in SQL migration
}

// ---------------------------------------------------------------------------
// MODEL: ContactTag
// Join table linking Contact to Tag with assignment metadata.
// Composite primary key prevents duplicate links.
// ---------------------------------------------------------------------------
model ContactTag {
  contactId String
  tagId     String

  contact Contact @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag     Tag     @relation(fields: [tagId], references: [id], onDelete: Cascade)

  assignedBy AssignedBy
  assignedAt DateTime   @default(now()) // When the link was created

  @@id([contactId, tagId]) // Composite PK - unique per pair
  @@index([tagId]) // Fast lookup by tag
}

// ---------------------------------------------------------------------------
// MODEL: InteractionTag
// Join table linking Interaction to Tag with assignment metadata.
// Composite primary key prevents duplicate links.
// ---------------------------------------------------------------------------
model InteractionTag {
  interactionId String
  tagId         String

  interaction Interaction @relation(fields: [interactionId], references: [id], onDelete: Cascade)
  tag         Tag         @relation(fields: [tagId], references: [id], onDelete: Cascade)

  assignedBy AssignedBy
  assignedAt DateTime   @default(now()) // When the link was created

  @@id([interactionId, tagId]) // Composite PK - unique per pair
  @@index([tagId]) // Fast lookup by tag
}
